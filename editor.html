<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-W3G0720L78"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-W3G0720L78');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess Blog Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: #0d1117;
      color: #e6edf3;
      overflow-x: hidden;
    }

    .editor-container {
      display: flex;
      height: 100vh;
    }

    .editor-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #30363d;
      position: relative;
    }

    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #161b22;
    }

    .panel-header {
      padding: 1rem 1.5rem;
      background: #21262d;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
      justify-content: between;
      gap: 1rem;
    }

    .panel-title {
      font-weight: 600;
      font-size: 0.9rem;
      color: #f0f6fc;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .github-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: #7d8590;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #7d8590;
    }

    .status-dot.connected {
      background: #238636;
    }

    .status-dot.error {
      background: #da3633;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .icon-btn {
      background: none;
      border: none;
      color: #7d8590;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 6px;
      display: flex;
      align-items: center;
      transition: all 0.2s;
      position: relative;
    }

    .icon-btn:hover {
      color: #e6edf3;
      background: #30363d;
    }

    .icon-btn.active {
      color: #58a6ff;
      background: rgba(88, 166, 255, 0.1);
    }

    .dropdown-menu {
      position: absolute;
      top: 100%;
      right: 0;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 0.5rem;
      min-width: 200px;
      display: none;
      z-index: 100;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .dropdown-menu.show {
      display: block;
    }

    .dropdown-item {
      padding: 0.5rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      transition: background-color 0.2s;
    }

    .dropdown-item:hover {
      background: #30363d;
    }

    .dropdown-divider {
      height: 1px;
      background: #30363d;
      margin: 0.5rem 0;
    }

    .form-group {
      margin-bottom: 0.75rem;
    }

    .form-label {
      display: block;
      font-size: 0.8rem;
      font-weight: 500;
      color: #f0f6fc;
      margin-bottom: 0.25rem;
    }

    .form-input,
    .form-select {
      width: 100%;
      background: #0d1117;
      border: 1px solid #30363d;
      color: #e6edf3;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      transition: border-color 0.2s;
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: #1f6feb;
    }

    .status-indicator {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      background: #1a7f37;
      color: white;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .status-indicator.show {
      opacity: 1;
    }

    .status-indicator.error {
      background: #da3633;
    }

    .status-indicator.warning {
      background: #fb8500;
    }

    .editor-textarea {
      flex: 1;
      background: #0d1117;
      border: none;
      outline: none;
      padding: 1.5rem;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: #e6edf3;
      resize: none;
      tab-size: 2;
    }

    .editor-textarea::placeholder {
      color: #7d8590;
    }

    .preview-iframe {
      flex: 1;
      width: 100%;
      height: 100%;
      border: none;
      background: white;
    }

    .preview-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7d8590;
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .preview-content {
      flex: 1;
      position: relative;
    }

    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #30363d;
      border-top: 2px solid #58a6ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .auto-refresh-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
    }

    .toggle-switch {
      position: relative;
      width: 40px;
      height: 20px;
      background: #484f58;
      border-radius: 20px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .toggle-switch.active {
      background: #238636;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(20px);
    }

    .preview-url {
      font-size: 0.7rem;
      color: #7d8590;
      font-family: monospace;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 2rem;
      min-width: 500px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-overlay.show .modal {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
    }

    .modal-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #f0f6fc;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .modal-close {
      background: none;
      border: none;
      color: #7d8590;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
    }

    .modal-close:hover {
      color: #e6edf3;
    }

    .form-help {
      font-size: 0.75rem;
      color: #7d8590;
      margin-top: 0.25rem;
    }

    .modal-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      margin-top: 1.5rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: #238636;
      border: 1px solid #2ea043;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #2ea043;
    }

    .btn-secondary {
      background: #21262d;
      border: 1px solid #30363d;
      color: #e6edf3;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #30363d;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* AI Chat Interface - Floating Style */
    .ai-chat {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 400px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transform: translateY(calc(100% + 2rem));
      transition: transform 0.3s ease;
      z-index: 200;
    }

    .ai-chat.open {
      transform: translateY(0);
    }

    .ai-chat-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .ai-chat-title {
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .ai-chat-model-name {
      font-size: 0.75rem;
      color: #7d8590;
      background: #0d1117;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }

    .model-selector {
      background: #0d1117;
      border: 1px solid #30363d;
      color: #e6edf3;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      min-width: 150px;
    }

    .ai-chat-body {
      padding: 1rem;
    }

    .ai-input-area {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .ai-input {
      flex: 1;
      background: #0d1117;
      border: 1px solid #30363d;
      color: #e6edf3;
      padding: 0.75rem;
      border-radius: 8px;
      font-size: 0.9rem;
      resize: none;
      min-height: 44px;
      max-height: 120px;
      line-height: 1.4;
    }

    .ai-input:focus {
      outline: none;
      border-color: #1f6feb;
      box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.1);
    }

    .ai-send-btn {
      background: #238636;
      border: 1px solid #2ea043;
      color: white;
      padding: 0.75rem;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      min-width: 44px;
      height: 44px;
    }

    .ai-send-btn:hover:not(:disabled) {
      background: #2ea043;
    }

    .ai-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* File Upload */
    .file-upload {
      position: relative;
      display: inline-block;
    }

    .file-upload input[type=file] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .file-upload-btn {
      background: #21262d;
      border: 1px solid #30363d;
      color: #e6edf3;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background-color 0.2s;
    }

    .file-upload-btn:hover {
      background: #30363d;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .editor-container {
        flex-direction: column;
      }

      .editor-panel {
        border-right: none;
        border-bottom: 1px solid #30363d;
      }

      .editor-panel,
      .preview-panel {
        height: 50vh;
      }

      .modal {
        min-width: 90vw;
        margin: 1rem;
      }

      .ai-chat {
        width: calc(100vw - 2rem);
        right: 1rem;
        bottom: 1rem;
      }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #21262d;
    }

    ::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #484f58;
    }

    .hidden-input {
      display: none;
    }
  </style>
</head>

<body>
  <div class="editor-container">
    <div class="editor-panel">
      <div class="panel-header">
        <div class="panel-title">
          <span class="material-icons">edit</span>
          <div class="github-status">
            <div class="status-dot" id="githubStatusDot"></div>
            <span id="githubStatusText">Not connected</span>
          </div>
        </div>

        <div class="header-controls">
          <div class="status-indicator" id="saveStatus">Saved</div>

          <!-- File Management Dropdown -->
          <div class="icon-btn" id="fileMenuBtn" title="File Management">
            <span class="material-icons">folder</span>
            <div class="dropdown-menu" id="fileMenu">
              <div class="form-group">
                <label class="form-label">Load File</label>
                <select class="form-select" id="fileSelector">
                  <option value="">Select a file...</option>
                </select>
              </div>
              <div class="dropdown-divider"></div>
              <div class="form-group">
                <label class="form-label">Filename</label>
                <input type="text" class="form-input" id="uploadFilename" placeholder="filename.md">
              </div>
              <div class="dropdown-item" id="savePostBtn">
                <span class="material-icons" style="font-size: 16px;">publish</span>
                Save as Post
              </div>
              <div class="dropdown-item" id="saveDraftBtn">
                <span class="material-icons" style="font-size: 16px;">draft</span>
                Save as Draft
              </div>
              <div class="dropdown-divider"></div>
              <div class="file-upload">
                <input type="file" id="imageUpload" accept="image/*" multiple>
                <div class="dropdown-item file-upload-btn">
                  <span class="material-icons" style="font-size: 16px;">image</span>
                  Upload Images
                </div>
              </div>
            </div>
          </div>

          <!-- AI Chat Toggle -->
          <div class="icon-btn" id="aiChatToggle" title="AI Assistant">
            <span class="material-icons">smart_toy</span>
          </div>

          <!-- Settings -->
          <div class="icon-btn" id="settingsBtn" title="GitHub Settings">
            <span class="material-icons">settings</span>
          </div>
        </div>
      </div>

      <textarea class="editor-textarea" id="markdownEditor" placeholder="Start writing your chess blog post...

Example:
---
title: &quot;My Chess Journey&quot;
date: 2025-06-23
image: &quot;https://example.com/image.jpg&quot;
layout: post
---

# Welcome to Chess

This is a basic chess position:
<chess-board fen=&quot;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1&quot;></chess-board>

You can highlight squares and draw arrows:
<chess-board fen=&quot;rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1&quot; highlight=&quot;e4&quot; arrows=&quot;e2-e4&quot;></chess-board>

## Chess Strategy

Chess is a game of **strategy** and *tactics*. Here are some key concepts:

1. **Control the center** - Place pawns and pieces in the center
2. **Develop your pieces** - Bring knights and bishops out early
3. **King safety** - Castle early to protect your king

> &quot;Every chess master was once a beginner.&quot; - Irving Chernev

---

### Opening Principles

The opening phase is crucial for setting up a good position...
"></textarea>

      <!-- AI Chat Interface -->
      <div class="ai-chat" id="aiChat">
        <div class="ai-chat-header">
          <div class="ai-chat-title">
            <span class="material-icons" style="font-size: 18px;">smart_toy</span>
            AI Assistant
            <span class="ai-chat-model-name" id="aiChatModelName"></span>
          </div>
          <div class="icon-btn" id="aiChatClose" title="Close AI Chat">
            <span class="material-icons">close</span>
          </div>
        </div>
        <div class="ai-chat-body">
          <div class="ai-input-area">
            <textarea class="ai-input" id="aiInput"
              placeholder="Tell me what to write or how to edit the content..."></textarea>
            <button class="ai-send-btn" id="aiSendBtn" title="Send">
              <span class="material-icons" style="font-size: 20px;">send</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="preview-panel">
      <div class="panel-header">
        <div class="panel-title">
          <span class="material-icons">visibility</span>
          Live Preview
          <div class="preview-url" id="previewUrl">Loading...</div>
        </div>
        <div class="header-controls">
          <div class="auto-refresh-toggle">
            <span>Auto-refresh</span>
            <div class="toggle-switch active" id="autoRefreshToggle">
              <div class="toggle-slider"></div>
            </div>
          </div>
          <div class="icon-btn" id="refreshBtn" title="Refresh Preview">
            <span class="material-icons">refresh</span>
          </div>
        </div>
      </div>
      <div class="preview-content">
        <div class="preview-loading" id="previewLoading">
          <div class="loading-spinner"></div>
          <span>Loading preview...</span>
        </div>
        <iframe class="preview-iframe" id="previewFrame" style="display: none;"></iframe>
      </div>
    </div>
  </div>

  <!-- GitHub Settings Modal -->
  <div class="modal-overlay" id="githubModal">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">
          <span class="material-icons">settings</span>
          GitHub & AI Configuration
        </div>
        <button class="modal-close" id="modalClose">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="modal-body">
        <h3 style="color: #f0f6fc; margin-bottom: 1rem;">GitHub Settings</h3>

        <div class="form-group">
          <label class="form-label" for="githubRepo">Repository (username/repo-name)</label>
          <input type="text" class="form-input" id="githubRepo" placeholder="your-username/your-blog-repo"
            autocomplete="url">
          <div class="form-help">Enter your GitHub repository in the format: username/repository-name</div>
        </div>

        <div class="form-group">
          <label class="form-label" for="githubToken">Personal Access Token</label>
          <input type="password" class="form-input" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
            autocomplete="current-password">
          <div class="form-help">
            Create a token at <a href="https://github.com/settings/tokens" target="_blank"
              style="color: #58a6ff;">github.com/settings/tokens</a>
            with 'repo' and 'contents:write' permissions. Also works as GitHub Models token.
          </div>
        </div>

        <h3 style="color: #f0f6fc; margin: 2rem 0 1rem 0;">AI Assistant Settings</h3>

        <div class="form-group">
          <label class="form-label" for="aiProvider">AI Provider</label>
          <select class="form-select" id="aiProvider">
            <option value="github">GitHub Models</option>
            <option value="gemini">Google Gemini</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label" for="geminiApiKey">Google Gemini API Key</label>
          <input type="password" class="form-input" id="geminiApiKey" placeholder="Enter your Gemini API Key"
            autocomplete="off">
          <div class="form-help">Used when "Google Gemini" is selected as the provider.</div>
        </div>

        <div class="form-group">
          <label class="form-label" for="aiModelId">AI Model ID</label>
          <input type="text" class="form-input" id="aiModelId" placeholder="gpt-4o-mini" value="gpt-4o-mini">
          <div class="form-help">Enter the model ID (e.g., gpt-4o-mini, gemini-1.5-flash-latest).</div>
        </div>

        <div class="form-group">
          <label class="form-label" for="aiSystemPrompt">System Instructions for AI</label>
          <textarea class="form-input" id="aiSystemPrompt" rows="6"
            placeholder="You are a helpful chess writing assistant..."></textarea>
          <div class="form-help">Customize how the AI assistant behaves and responds to your requests</div>
        </div>
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
        <button class="btn btn-primary" id="connectBtn">
          <span class="material-icons" style="font-size: 18px;">save</span>
          Save Settings
        </button>
      </div>
    </div>
  </div>

  <script>
    class ChessEditorPreview {
      constructor() {
        this.editor = document.getElementById('markdownEditor');
        this.previewFrame = document.getElementById('previewFrame');
        this.previewLoading = document.getElementById('previewLoading');
        this.previewUrl = document.getElementById('previewUrl');
        this.saveStatus = document.getElementById('saveStatus');
        this.refreshBtn = document.getElementById('refreshBtn');
        this.autoRefreshToggle = document.getElementById('autoRefreshToggle');

        // GitHub elements
        this.githubModal = document.getElementById('githubModal');
        this.settingsBtn = document.getElementById('settingsBtn');
        this.fileSelector = document.getElementById('fileSelector');
        this.uploadFilename = document.getElementById('uploadFilename');
        this.githubStatusDot = document.getElementById('githubStatusDot');
        this.githubStatusText = document.getElementById('githubStatusText');
        this.modalClose = document.getElementById('modalClose');
        this.cancelBtn = document.getElementById('cancelBtn');
        this.connectBtn = document.getElementById('connectBtn');
        this.githubRepo = document.getElementById('githubRepo');
        this.githubToken = document.getElementById('githubToken');

        // File management elements
        this.fileMenuBtn = document.getElementById('fileMenuBtn');
        this.fileMenu = document.getElementById('fileMenu');
        this.savePostBtn = document.getElementById('savePostBtn');
        this.saveDraftBtn = document.getElementById('saveDraftBtn');
        this.imageUpload = document.getElementById('imageUpload');

        // AI Chat elements
        this.aiChatToggle = document.getElementById('aiChatToggle');
        this.aiChat = document.getElementById('aiChat');
        this.aiChatClose = document.getElementById('aiChatClose');
        this.aiInput = document.getElementById('aiInput');
        this.aiSendBtn = document.getElementById('aiSendBtn');
        this.aiSystemPrompt = document.getElementById('aiSystemPrompt');
        this.aiModelId = document.getElementById('aiModelId');
        this.aiProvider = document.getElementById('aiProvider');
        this.geminiApiKey = document.getElementById('geminiApiKey');
        this.aiChatModelName = document.getElementById('aiChatModelName');

        this.autoRefresh = true;
        this.updateTimeout = null;
        this.isFrameReady = false;
        this.aiChatOpen = false;

        // GitHub state
        this.github = {
          connected: false,
          repo: null,
          token: null,
          owner: null,
          repoName: null
        };

        this.init();
      }

      init() {
        // Load saved content
        const savedContent = localStorage.getItem('chessMarkdownEditor');
        if (savedContent) {
          this.editor.value = savedContent;
        }

        // Load saved GitHub credentials and AI settings
        this.loadSettings();

        // Setup event listeners
        this.editor.addEventListener('input', () => this.handleEditorInput());
        this.editor.addEventListener('keydown', (e) => this.handleTabKey(e));

        this.refreshBtn.addEventListener('click', () => this.updatePreview(true));

        this.autoRefreshToggle.addEventListener('click', () => {
          this.autoRefresh = !this.autoRefresh;
          this.autoRefreshToggle.classList.toggle('active', this.autoRefresh);
          if (this.autoRefresh) {
            this.updatePreview();
          }
        });

        // GitHub event listeners
        this.settingsBtn.addEventListener('click', () => this.showGitHubModal());
        this.modalClose.addEventListener('click', () => this.hideGitHubModal());
        this.cancelBtn.addEventListener('click', () => this.hideGitHubModal());
        this.connectBtn.addEventListener('click', () => this.saveSettings());
        this.fileSelector.addEventListener('change', () => this.loadSelectedFile());

        // File management
        this.fileMenuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.fileMenu.classList.toggle('show');
          if (this.fileMenu.classList.contains('show')) {
            this.autofillFilename();
          }
        });
        // Prevent dropdown from closing on inner clicks
        this.fileMenu.addEventListener('click', (e) => e.stopPropagation());

        this.savePostBtn.addEventListener('click', () => this.uploadToGitHub('_posts'));
        this.saveDraftBtn.addEventListener('click', () => this.uploadToGitHub('_drafts'));
        this.imageUpload.addEventListener('change', () => this.uploadImages());

        // AI Chat
        this.aiChatToggle.addEventListener('click', () => this.toggleAIChat());
        this.aiChatClose.addEventListener('click', () => this.toggleAIChat());
        this.aiSendBtn.addEventListener('click', () => this.sendAIMessage());
        this.aiInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.sendAIMessage();
          }
        });

        // Modal overlay click to close
        this.githubModal.addEventListener('click', (e) => {
          if (e.target === this.githubModal) {
            this.hideGitHubModal();
          }
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
          if (!this.fileMenuBtn.contains(e.target) && !this.fileMenu.contains(e.target)) {
            this.fileMenu.classList.remove('show');
          }
        });

        // Setup iframe message listener
        window.addEventListener('message', (event) => this.handleFrameMessage(event));

        // Initialize preview
        this.setupPreviewFrame();
      }

      loadSettings() {
        const savedRepo = localStorage.getItem('githubRepo');
        const savedToken = localStorage.getItem('githubToken');
        const savedProvider = localStorage.getItem('aiProvider');
        const savedGeminiKey = localStorage.getItem('geminiApiKey');
        const savedSystemPrompt = localStorage.getItem('aiSystemPrompt');
        const savedModelId = localStorage.getItem('aiModelId');

        if (savedRepo && savedToken) {
          this.githubRepo.value = savedRepo;
          this.githubToken.value = savedToken;
          this.connectToGitHub(false); // Connect silently
        }

        if (savedProvider) {
          this.aiProvider.value = savedProvider;
        }

        if (savedGeminiKey) {
          this.geminiApiKey.value = savedGeminiKey;
        }

        if (savedSystemPrompt) {
          this.aiSystemPrompt.value = savedSystemPrompt;
        } else {
          // Set default prompt if none is saved
          this.aiSystemPrompt.value = `You are a helpful chess writing assistant. You specialize in creating engaging chess blog posts, analyzing positions, and explaining chess concepts.

When asked to generate or edit chess content, you MUST use the custom <chess-board> HTML tag.
- Use the 'fen' attribute for the board position (e.g., fen="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1").
- Use the 'highlight' attribute to highlight squares (e.g., highlight="e4,d4").
- Use the 'arrows' attribute to draw arrows (e.g., arrows="e2-e4,g1-f3").

When editing existing text, maintain the author's voice while improving clarity, flow, and chess accuracy. Ensure all FEN strings and move notations are correct.`;
        }

        if (savedModelId) {
          this.aiModelId.value = savedModelId;
        }
        this.aiChatModelName.textContent = this.aiModelId.value;
      }

      showGitHubModal() {
        this.githubModal.classList.add('show');
        this.githubRepo.focus();
      }

      hideGitHubModal() {
        this.githubModal.classList.remove('show');
      }

      async saveSettings() {
        const repo = this.githubRepo.value.trim();
        const token = this.githubToken.value.trim();
        const provider = this.aiProvider.value;
        const geminiKey = this.geminiApiKey.value.trim();
        const systemPrompt = this.aiSystemPrompt.value.trim();
        const modelId = this.aiModelId.value.trim();

        // Save AI settings
        localStorage.setItem('aiProvider', provider);
        localStorage.setItem('geminiApiKey', geminiKey);
        localStorage.setItem('aiSystemPrompt', systemPrompt);
        localStorage.setItem('aiModelId', modelId);
        this.aiChatModelName.textContent = modelId;

        if (!repo || !token) {
          this.showStatus('Please fill in both repository and token', 'error');
          return;
        }

        if (!repo.includes('/')) {
          this.showStatus('Repository must be in format: username/repo-name', 'error');
          return;
        }

        this.connectBtn.disabled = true;
        this.connectBtn.innerHTML = '<div class="loading-spinner" style="width: 16px; height: 16px;"></div> Connecting...';

        try {
          const [owner, repoName] = repo.split('/');

          // Test the connection by fetching repository info
          const response = await fetch(`https://api.github.com/repos/${repo}`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });

          if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
          }

          const repoData = await response.json();

          // Save credentials
          localStorage.setItem('githubRepo', repo);
          localStorage.setItem('githubToken', token);

          // Update state
          this.github = {
            connected: true,
            repo: repo,
            token: token,
            owner: owner,
            repoName: repoName
          };

          // Update UI
          this.updateGitHubStatus();
          this.loadFileList();

          this.hideGitHubModal();
          this.showStatus('Settings saved successfully!', 'success');

        } catch (error) {
          console.error('GitHub connection error:', error);
          this.showStatus(`Connection failed: ${error.message}`, 'error');
          this.github.connected = false;
          this.updateGitHubStatus();
        } finally {
          this.connectBtn.disabled = false;
          this.connectBtn.innerHTML = '<span class="material-icons" style="font-size: 18px;">save</span> Save Settings';
        }
      }

      async connectToGitHub(showModal = true) {
        const repo = this.githubRepo.value.trim();
        const token = this.githubToken.value.trim();

        if (!repo || !token) return;

        try {
          const [owner, repoName] = repo.split('/');

          const response = await fetch(`https://api.github.com/repos/${repo}`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });

          if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status}`);
          }

          this.github = {
            connected: true,
            repo: repo,
            token: token,
            owner: owner,
            repoName: repoName
          };

          this.updateGitHubStatus();
          this.loadFileList();

        } catch (error) {
          this.github.connected = false;
          this.updateGitHubStatus();
        }
      }

      updateGitHubStatus() {
        if (this.github.connected) {
          this.githubStatusDot.classList.add('connected');
          this.githubStatusDot.classList.remove('error');
          this.githubStatusText.textContent = `Connected: ${this.github.repo}`;
        } else {
          this.githubStatusDot.classList.remove('connected');
          this.githubStatusDot.classList.add('error');
          this.githubStatusText.textContent = 'Not connected';
        }
      }

      async loadFileList() {
        if (!this.github.connected) return;

        try {
          // Load both posts and drafts
          const [postsResponse, draftsResponse] = await Promise.all([
            fetch(`https://api.github.com/repos/${this.github.repo}/contents/_posts`, {
              headers: {
                'Authorization': `Bearer ${this.github.token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            }).catch(() => ({ ok: false, status: 404 })),
            fetch(`https://api.github.com/repos/${this.github.repo}/contents/_drafts`, {
              headers: {
                'Authorization': `Bearer ${this.github.token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            }).catch(() => ({ ok: false, status: 404 }))
          ]);

          this.fileSelector.innerHTML = '<option value="">Select a file to load...</option>';

          // Add posts
          if (postsResponse.ok) {
            const posts = await postsResponse.json();
            const markdownPosts = posts.filter(file =>
              file.type === 'file' && (file.name.endsWith('.md') || file.name.endsWith('.markdown'))
            );

            if (markdownPosts.length > 0) {
              const postsGroup = document.createElement('optgroup');
              postsGroup.label = 'Posts';
              markdownPosts.forEach(file => {
                const option = document.createElement('option');
                option.value = file.sha;
                option.textContent = file.name;
                option.dataset.downloadUrl = file.download_url;
                option.dataset.filename = file.name;
                option.dataset.type = '_posts';
                postsGroup.appendChild(option);
              });
              this.fileSelector.appendChild(postsGroup);
            }
          }

          // Add drafts
          if (draftsResponse.ok) {
            const drafts = await draftsResponse.json();
            const markdownDrafts = drafts.filter(file =>
              file.type === 'file' && (file.name.endsWith('.md') || file.name.endsWith('.markdown'))
            );

            if (markdownDrafts.length > 0) {
              const draftsGroup = document.createElement('optgroup');
              draftsGroup.label = 'Drafts';
              markdownDrafts.forEach(file => {
                const option = document.createElement('option');
                option.value = file.sha;
                option.textContent = file.name;
                option.dataset.downloadUrl = file.download_url;
                option.dataset.filename = file.name;
                option.dataset.type = '_drafts';
                draftsGroup.appendChild(option);
              });
              this.fileSelector.appendChild(draftsGroup);
            }
          }

          if (this.fileSelector.children.length === 1) {
            this.fileSelector.innerHTML = '<option value="">No markdown files found</option>';
          }

        } catch (error) {
          console.error('Error loading file list:', error);
          this.showStatus(`Failed to load files: ${error.message}`, 'error');
        }
      }

      async loadSelectedFile() {
        const selectedOption = this.fileSelector.selectedOptions[0];
        if (!selectedOption || !selectedOption.value) return;

        const downloadUrl = selectedOption.dataset.downloadUrl;
        const filename = selectedOption.dataset.filename;

        try {
          this.showStatus('Loading file...', 'loading');

          const response = await fetch(downloadUrl);
          if (!response.ok) {
            throw new Error(`Failed to load file: ${response.statusText}`);
          }

          const content = await response.text();
          this.editor.value = content;

          // Update filename for potential upload
          this.uploadFilename.value = filename;

          // Save to localStorage
          localStorage.setItem('chessMarkdownEditor', content);

          this.showStatus(`Loaded ${filename}`, 'success');

          // Update preview if auto-refresh is enabled
          if (this.autoRefresh) {
            this.updatePreview();
          }

        } catch (error) {
          console.error('Error loading file:', error);
          this.showStatus(`Failed to load file: ${error.message}`, 'error');
        }
      }

      async uploadToGitHub(folder) {
        if (!this.github.connected) {
          this.showStatus('Please connect to GitHub first', 'error');
          return;
        }

        const filename = this.uploadFilename.value.trim();
        const content = this.editor.value.trim();

        if (!filename || !content) {
          this.showStatus('Please provide both filename and content', 'error');
          return;
        }

        if (!filename.endsWith('.md') && !filename.endsWith('.markdown')) {
          this.showStatus('Filename must end with .md or .markdown', 'error');
          return;
        }

        this.showStatus('Uploading...', 'loading');

        try {
          // Check if file already exists
          let sha = null;
          try {
            const existingFileResponse = await fetch(
              `https://api.github.com/repos/${this.github.repo}/contents/${folder}/${filename}`,
              {
                headers: {
                  'Authorization': `Bearer ${this.github.token}`,
                  'Accept': 'application/vnd.github.v3+json'
                }
              }
            );

            if (existingFileResponse.ok) {
              const existingFile = await existingFileResponse.json();
              sha = existingFile.sha;
            }
          } catch (error) {
            // File doesn't exist, which is fine
          }

          // Upload the file
          const uploadData = {
            message: sha ? `Update ${filename}` : `Add ${filename}`,
            content: btoa(unescape(encodeURIComponent(content))), // Base64 encode with proper UTF-8 handling
            branch: 'main' // or 'master', adjust as needed
          };

          if (sha) {
            uploadData.sha = sha; // Required for updates
          }

          const uploadResponse = await fetch(
            `https://api.github.com/repos/${this.github.repo}/contents/${folder}/${filename}`,
            {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${this.github.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(uploadData)
            }
          );

          if (!uploadResponse.ok) {
            const errorData = await uploadResponse.json();
            throw new Error(errorData.message || `Upload failed: ${uploadResponse.statusText}`);
          }

          const result = await uploadResponse.json();
          const action = sha ? 'updated' : 'uploaded';
          const folderName = folder === '_posts' ? 'post' : 'draft';
          this.showStatus(`Successfully ${action} ${filename} as ${folderName}!`, 'success');

          // Refresh file list and close menu
          setTimeout(() => {
            this.loadFileList();
            this.fileMenu.classList.remove('show');
          }, 1000);

        } catch (error) {
          console.error('Upload error:', error);
          this.showStatus(`Upload failed: ${error.message}`, 'error');
        }
      }

      async uploadImages() {
        if (!this.github.connected) {
          this.showStatus('Please connect to GitHub first', 'error');
          return;
        }

        const files = this.imageUpload.files;
        if (files.length === 0) return;

        this.showStatus('Uploading images...', 'loading');

        try {
          const uploadPromises = Array.from(files).map(async (file) => {
            const reader = new FileReader();
            return new Promise((resolve, reject) => {
              reader.onload = async () => {
                try {
                  const base64Content = reader.result.split(',')[1];
                  const filename = file.name;

                  const uploadData = {
                    message: `Add image ${filename}`,
                    content: base64Content,
                    branch: 'main'
                  };

                  const uploadResponse = await fetch(
                    `https://api.github.com/repos/${this.github.repo}/contents/images/${filename}`,
                    {
                      method: 'PUT',
                      headers: {
                        'Authorization': `Bearer ${this.github.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                      },
                      body: JSON.stringify(uploadData)
                    }
                  );

                  if (!uploadResponse.ok) {
                    const errorData = await uploadResponse.json();
                    throw new Error(errorData.message || `Failed to upload ${filename}`);
                  }

                  resolve(filename);
                } catch (error) {
                  reject(error);
                }
              };
              reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
              reader.readAsDataURL(file);
            });
          });

          const uploadedFiles = await Promise.all(uploadPromises);

          // Insert image references into the editor
          const imageMarkdown = uploadedFiles.map(filename =>
            `![${filename}](./images/${filename})`
          ).join('\n\n');

          const cursorPos = this.editor.selectionStart;
          const beforeCursor = this.editor.value.substring(0, cursorPos);
          const afterCursor = this.editor.value.substring(cursorPos);

          this.editor.value = beforeCursor + '\n\n' + imageMarkdown + '\n\n' + afterCursor;

          // Save content and update preview
          localStorage.setItem('chessMarkdownEditor', this.editor.value);
          if (this.autoRefresh) {
            this.updatePreview();
          }

          this.showStatus(`Successfully uploaded ${uploadedFiles.length} image(s)!`, 'success');
          this.fileMenu.classList.remove('show');

        } catch (error) {
          console.error('Image upload error:', error);
          this.showStatus(`Image upload failed: ${error.message}`, 'error');
        }

        // Clear the file input
        this.imageUpload.value = '';
      }

      toggleAIChat() {
        this.aiChatOpen = !this.aiChatOpen;
        this.aiChat.classList.toggle('open', this.aiChatOpen);
        this.aiChatToggle.classList.toggle('active', this.aiChatOpen);

        if (this.aiChatOpen) {
          this.aiInput.focus();
        }
      }

      async sendAIMessage() {
        const message = this.aiInput.value.trim();
        if (!message) return;

        const provider = this.aiProvider.value;

        this.aiInput.value = '';
        this.aiSendBtn.disabled = true;
        this.aiSendBtn.innerHTML = '<div class="loading-spinner" style="width: 16px; height: 16px;"></div>';

        try {
          if (provider === 'github') {
            await this.sendGitHubAIMessage(message);
          } else if (provider === 'gemini') {
            await this.sendGeminiAIMessage(message);
          }
        } catch (error) {
          console.error('AI error:', error);
          this.showStatus(`AI error: ${error.message}`, 'error');
        } finally {
          this.aiSendBtn.disabled = false;
          this.aiSendBtn.innerHTML = '<span class="material-icons" style="font-size: 18px;">send</span>';
          this.aiInput.focus();
        }
      }

      async sendGitHubAIMessage(message) {
        if (!this.github.token) {
          throw new Error('Please set up GitHub token for AI features');
        }

        const systemPrompt = this.aiSystemPrompt.value;
        const modelId = this.aiModelId.value || 'gpt-4o-mini';

        const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.github.token}`
          },
          body: JSON.stringify({
            model: modelId,
            messages: [
              {
                role: 'system',
                content: `${systemPrompt}\n\nIMPORTANT: You must respond with valid JSON in this exact format:\n{\n  "content": "the complete markdown content that should replace the entire editor",\n  "message": "brief description of what you did"\n}\n\nCurrent document content:\n${this.editor.value}`
              },
              { role: 'user', content: message }
            ],
            temperature: 0.7,
            max_tokens: 4000
          })
        });

        if (!response.ok) {
          throw new Error(`GitHub AI API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const aiResponse = data.choices[0].message.content;
        this.processAIResponse(aiResponse);
      }

      async sendGeminiAIMessage(message) {
        const apiKey = this.geminiApiKey.value.trim();
        if (!apiKey) {
          throw new Error('Please provide your Google Gemini API Key');
        }

        const systemPrompt = this.aiSystemPrompt.value;
        const modelId = this.aiModelId.value || 'gemini-1.5-flash-latest';
        const GEN_API = "streamGenerateContent";

        const requestBody = {
          contents: [
            {
              role: "user",
              parts: [{ text: `${systemPrompt}\n\nIMPORTANT: You must respond with valid JSON in this exact format:\n{\n  "content": "the complete markdown content that should replace the entire editor",\n  "message": "brief description of what you did"\n}\n\nCurrent document content:\n${this.editor.value}\n\nUser request: ${message}` }]
            }
          ],
          generationConfig: { "thinkingConfig": { "thinkingBudget": -1 } },
          tools: [{ "googleSearch": {} }]
        };

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:${GEN_API}?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const responseText = await response.text();
        // The streaming API returns multiple JSON objects. We need to combine them.
        const combinedJson = JSON.parse(responseText.replace(/,$/, ''));
        const aiResponse = combinedJson.candidates[0].content.parts[0].text;
        this.processAIResponse(aiResponse);
      }

      processAIResponse(aiResponse) {
        try {
          const jsonResponse = JSON.parse(aiResponse);
          if (jsonResponse.content) {
            this.editor.value = jsonResponse.content;
            localStorage.setItem('chessMarkdownEditor', this.editor.value);
            if (this.autoRefresh) this.updatePreview();
            this.showStatus(jsonResponse.message || 'Content updated by AI', 'success');
            this.toggleAIChat();
          } else {
            throw new Error('Invalid AI response format');
          }
        } catch (parseError) {
          // Fallback for non-JSON responses
          this.editor.value = aiResponse;
          localStorage.setItem('chessMarkdownEditor', this.editor.value);
          if (this.autoRefresh) this.updatePreview();
          this.showStatus('Content updated by AI', 'success');
          this.toggleAIChat();
        }
      }

      setupPreviewFrame() {
        const postHtmlUrl = '_layouts/post.html';

        this.previewUrl.textContent = postHtmlUrl;
        this.previewFrame.src = postHtmlUrl;

        this.previewFrame.onload = () => {
          this.previewLoading.style.display = 'none';
          this.previewFrame.style.display = 'block';

          setTimeout(() => {
            this.isFrameReady = true;
            this.updatePreview();
          }, 500);
        };

        this.previewFrame.onerror = () => {
          this.previewLoading.innerHTML = `
            <span style="color: #f85149;">
              ⚠️ Failed to load post.html<br>
              <small>Make sure post.html is accessible at: ${postHtmlUrl}</small>
            </span>
          `;
        };
      }

      handleFrameMessage(event) {
        if (event.data.type === 'preview-ready') {
          this.isFrameReady = true;
          this.updatePreview();
        } else if (event.data.type === 'preview-updated') {
          console.log('Preview updated successfully');
        } else if (event.data.type === 'preview-error') {
          console.error('Preview error:', event.data.error);
        }
      }

      handleEditorInput() {
        localStorage.setItem('chessMarkdownEditor', this.editor.value);
        this.showSaveStatus();

        if (this.autoRefresh) {
          this.scheduleUpdate();
        }
      }

      handleTabKey(e) {
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = this.editor.selectionStart;
          const end = this.editor.selectionEnd;
          this.editor.value = this.editor.value.substring(0, start) + '  ' + this.editor.value.substring(end);
          this.editor.selectionStart = this.editor.selectionEnd = start + 2;
        }
      }

      scheduleUpdate() {
        clearTimeout(this.updateTimeout);
        this.updateTimeout = setTimeout(() => {
          this.updatePreview();
        }, 800);
      }

      updatePreview(force = false) {
        if (!this.isFrameReady && !force) {
          return;
        }

        const markdown = this.editor.value;
        const processed = this.processMarkdown(markdown);

        this.previewFrame.contentWindow.postMessage({
          type: 'update-content',
          frontMatter: processed.frontMatter,
          content: processed.content,
          rawMarkdown: markdown
        }, '*');

        this.refreshBtn.disabled = true;
        setTimeout(() => {
          this.refreshBtn.disabled = false;
        }, 1000);
      }

      processMarkdown(markdown) {
        const result = { frontMatter: {}, content: '' };

        const yamlMatch = markdown.match(/^---\n([\s\S]*?)\n---\n?([\s\S]*)$/);
        if (yamlMatch) {
          result.frontMatter = this.parseYAML(yamlMatch[1]);
          result.content = yamlMatch[2];
        } else {
          result.frontMatter = {
            title: "Preview Post",
            date: new Date().toISOString().split('T')[0],
            layout: "post"
          };
          result.content = markdown.replace(/^---[\s\S]*?---\n?/, '');
        }

        return result;
      }

      parseYAML(yamlStr) {
        const lines = yamlStr.split('\n').filter(line => line.trim());
        const data = {};

        lines.forEach(line => {
          const colonIndex = line.indexOf(':');
          if (colonIndex > 0) {
            const key = line.substring(0, colonIndex).trim();
            let value = line.substring(colonIndex + 1).trim();
            if ((value.startsWith('"') && value.endsWith('"')) ||
              (value.startsWith("'") && value.endsWith("'"))) {
              value = value.slice(1, -1);
            }
            data[key] = value;
          }
        });

        return data;
      }

      autofillFilename() {
        const frontMatter = this.processMarkdown(this.editor.value).frontMatter;
        const title = frontMatter.title;
        const date = frontMatter.date;

        if (title && date) {
          const slug = title.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
          this.uploadFilename.value = `${date}-${slug}.md`;
        }
      }

      showSaveStatus() {
        this.saveStatus.textContent = 'Saving...';
        this.saveStatus.classList.add('show');
        this.saveStatus.classList.remove('error', 'warning');

        setTimeout(() => {
          this.saveStatus.textContent = 'Saved';
          setTimeout(() => {
            this.saveStatus.classList.remove('show');
          }, 1000);
        }, 500);
      }

      showStatus(message, type = 'info') {
        this.saveStatus.classList.remove('error', 'warning');

        if (type === 'error') {
          this.saveStatus.classList.add('error');
        } else if (type === 'warning') {
          this.saveStatus.classList.add('warning');
        }

        this.saveStatus.textContent = message;
        this.saveStatus.classList.add('show');

        if (type !== 'loading') {
          setTimeout(() => {
            this.saveStatus.classList.remove('show');
          }, type === 'error' ? 4000 : 2000);
        }
      }
    }

    // Initialize the editor
    document.addEventListener('DOMContentLoaded', () => {
      new ChessEditorPreview();
    });
  </script>
</body>

</html>