<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-W3G0720L78"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-W3G0720L78');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Blog Editor</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', sans-serif; background: #0d1117; color: #e6edf3; overflow-x: hidden; }
    .editor-container { display: flex; height: 100vh; }
    .editor-panel { flex: 1; display:flex; flex-direction: column; border-right:1px solid #30363d; position: relative; }
    .preview-panel { flex: 1; display:flex; flex-direction: column; background: #161b22; }
    .panel-header { padding:1rem 1.5rem; background: #21262d; border-bottom: 1px solid #30363d; display:flex; align-items:center; justify-content:space-between; gap:1rem; }
    .panel-title { font-weight:600; font-size:0.9rem; color:#f0f6fc; display:flex; align-items:center; gap:0.5rem; flex:1; }
    .github-status { display:flex; align-items:center; gap:0.5rem; font-size:0.75rem; color:#7d8590; }
    .status-dot { width:8px; height:8px; border-radius:50%; background:#7d8590; }
    .status-dot.connected { background:#238636; }
    .status-dot.error { background:#da3633; }
    .header-controls { display:flex; align-items:center; gap:0.75rem; }
    .icon-btn { background:none; border:none; color:#7d8590; cursor:pointer; padding:0.5rem; border-radius:6px; display:flex; align-items:center; transition:all 0.2s; position:relative; }
    .icon-btn:hover { color:#e6edf3; background:#30363d; }
    .icon-btn.active { color:#58a6ff; background: rgba(88,166,255,0.1); }
    .status-indicator { font-size:0.75rem; padding:0.25rem 0.5rem; border-radius:12px; background:#1a7f37; color:white; opacity:0; transition:opacity 0.3s; }
    .status-indicator.show { opacity:1; }
    .status-indicator.error { background:#da3633; }
    .status-indicator.warning { background:#fb8500; }

    /* filename bar */
    .filename-bar { padding: 0.75rem 1.5rem; background: #0f1418; border-bottom: 1px solid #30363d; display:flex; gap:0.75rem; align-items:center; }
    .filename-input { background: #0d1117; border: 1px solid #30363d; color: #e6edf3; padding: 0.5rem; border-radius: 6px; font-size: 0.9rem; min-width: 280px; }
    .folder-select { background: #0d1117; border: 1px solid #30363d; color: #e6edf3; padding: 0.5rem; border-radius:6px; font-size:0.9rem; }
    .save-editor-btn { background:#238636; border:1px solid #2ea043; color:white; padding:0.5rem 0.75rem; border-radius:6px; cursor:pointer; display:flex; gap:0.5rem; align-items:center; }
    .save-editor-btn:disabled { opacity:0.5; cursor:not-allowed; }

    .editor-textarea { flex:1; background:#0d1117; border:none; outline:none; padding:1.5rem; font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size:14px; line-height:1.6; color:#e6edf3; resize:none; tab-size:2; }
    .editor-textarea::placeholder { color:#7d8590; }
    .preview-iframe { flex:1; width:100%; height:100%; border:none; background:white; }
    .preview-loading { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#7d8590; font-size:0.9rem; display:flex; flex-direction:column; align-items:center; gap:0.5rem; }
    .preview-content { flex:1; position:relative; }
    .loading-spinner { width:20px; height:20px; border:2px solid #30363d; border-top:2px solid #58a6ff; border-radius:50%; animation:spin 1s linear infinite; }
    @keyframes spin { 0%{ transform:rotate(0deg);} 100%{ transform:rotate(360deg);} }

    .auto-refresh-toggle { display:flex; align-items:center; gap:0.5rem; font-size:0.8rem; }
    .toggle-switch { position:relative; width:40px; height:20px; background:#484f58; border-radius:20px; cursor:pointer; transition:background-color 0.3s; }
    .toggle-switch.active { background:#238636; }
    .toggle-slider { position:absolute; top:2px; left:2px; width:16px; height:16px; background:white; border-radius:50%; transition:transform 0.3s; }
    .toggle-switch.active .toggle-slider { transform:translateX(20px); }
    .preview-url { font-size:0.7rem; color:#7d8590; font-family:monospace; }

    /* Modal Styles (unchanged) */
    .modal-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:1000; opacity:0; visibility:hidden; transition:all 0.3s ease; }
    .modal-overlay.show { opacity:1; visibility:visible; }
    .modal { background:#21262d; border:1px solid #30363d; border-radius:12px; padding:2rem; min-width:500px; max-width:800px; max-height:80vh; overflow-y:auto; transform:scale(0.9); transition:transform 0.3s ease; }
    .modal-overlay.show .modal { transform:scale(1); }
    .modal-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:1.5rem; }
    .modal-title { font-size:1.1rem; font-weight:600; color:#f0f6fc; display:flex; align-items:center; gap:0.5rem; }
    .modal-close { background:none; border:none; color:#7d8590; cursor:pointer; padding:0.25rem; border-radius:6px; display:flex; align-items:center; justify-content:center; transition:color 0.2s; }
    .modal-close:hover { color:#e6edf3; }
    .form-group { margin-bottom:0.75rem; }
    .form-label { display:block; font-size:0.8rem; font-weight:500; color:#f0f6fc; margin-bottom:0.25rem; }
    .form-input, .form-select { width:100%; background:#0d1117; border:1px solid #30363d; color:#e6edf3; padding:0.5rem; border-radius:4px; font-size:0.8rem; transition:border-color 0.2s; }
    .form-input:focus, .form-select:focus { outline:none; border-color:#1f6feb; }
    .form-help { font-size:0.75rem; color:#7d8590; margin-top:0.25rem; }
    .modal-actions { display:flex; gap:0.75rem; justify-content:flex-end; margin-top:1.5rem; }
    .btn { padding:0.5rem 1rem; border-radius:6px; font-size:0.9rem; cursor:pointer; transition:all 0.2s; display:flex; align-items:center; gap:0.5rem; border:none; }
    .btn-primary { background:#238636; border:1px solid #2ea043; color:white; }
    .btn-secondary { background:#21262d; border:1px solid #30363d; color:#e6edf3; }
    .btn-danger { background:#da3633; border:1px solid #f85149; color:white; }
    .btn:disabled { opacity:0.5; cursor:not-allowed; }

    /* File Manager Styles (unchanged except small spacing) */
    .file-modal { min-width:700px; max-width:900px; }
    .file-tabs { display:flex; gap:0.5rem; margin-bottom:0.5rem; border-bottom:1px solid #30363d; }
    .file-tab { padding:0.5rem 0.75rem; background:none; border:none; color:#7d8590; cursor:pointer; border-radius:6px 6px 0 0; transition:all 0.2s; font-size:0.9rem; display:flex; align-items:center; gap:0.5rem; }
    .file-tab:hover { color:#e6edf3; background:#30363d; }
    .file-tab.active { color:#58a6ff; background: rgba(88,166,255,0.1); border-bottom:2px solid #58a6ff; }
    .file-list { min-height:200px; max-height:400px; overflow-y:auto; border:1px solid #30363d; border-radius:6px; background:#0d1117; padding:0.5rem; margin-top:0.75rem; }
    .file-item { display:flex; align-items:center; justify-content:space-between; padding:0.5rem; border-bottom:1px solid #30363d; cursor:pointer; transition:background-color 0.2s; }
    .file-item:last-child { border-bottom:none; }
    .file-item:hover { background:#161b22; }
    .file-item.selected { background: rgba(88,166,255,0.1); border-color:#58a6ff; }
    .file-info { display:flex; align-items:center; gap:0.75rem; flex:1; }
    .file-icon { width:20px; height:20px; display:flex; align-items:center; justify-content:center; color:#7d8590; }
    .file-details { flex:1; }
    .file-name { font-weight:500; color:#e6edf3; margin-bottom:0.25rem; }
    .file-meta { font-size:0.75rem; color:#7d8590; }
    .file-actions { display:flex; gap:0.5rem; opacity:0; transition:opacity 0.2s; }
    .file-item:hover .file-actions { opacity:1; }
    .file-action-btn { background:none; border:none; color:#7d8590; cursor:pointer; padding:0.25rem; border-radius:4px; display:flex; align-items:center; justify-content:center; transition:all 0.2s; }
    .file-action-btn:hover { color:#e6edf3; background:#30363d; }
    .file-action-btn.danger:hover { color:#f85149; background: rgba(248,81,73,0.1); }
    .upload-zone { border:2px dashed #30363d; border-radius:8px; padding:1rem; text-align:center; margin-bottom:1rem; transition:all 0.2s; cursor:pointer; }
    .upload-zone:hover, .upload-zone.drag-over { border-color:#58a6ff; background: rgba(88,166,255,0.05); }
    .upload-zone input[type="file"] { display:none; }

    .empty-state { text-align:center; padding:1rem; color:#7d8590; }
    .empty-state .material-icons { font-size:36px; margin-bottom:0.5rem; opacity:0.5; }

    /* AI Chat (unchanged) */
    .ai-chat { position:fixed; bottom:2rem; right:2rem; width:400px; background:#21262d; border:1px solid #30363d; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.3); transform:translateY(calc(100% + 2rem)); transition:transform 0.3s ease; z-index:200; }
    .ai-chat.open { transform:translateY(0); }
    .ai-chat-header { padding:0.75rem 1rem; border-bottom:1px solid #30363d; display:flex; align-items:center; justify-content:space-between; }
    .ai-chat-title { font-size:0.9rem; font-weight:500; display:flex; align-items:center; gap:0.5rem; }
    .ai-chat-model-name { font-size:0.75rem; color:#7d8590; background:#0d1117; padding:0.2rem 0.5rem; border-radius:4px; }
    .ai-chat-body { padding:1rem; }
    .ai-input-area { display:flex; gap:0.75rem; align-items:flex-end; }
    .ai-input { flex:1; background:#0d1117; border:1px solid #30363d; color:#e6edf3; padding:0.75rem; border-radius:8px; font-size:0.9rem; resize:none; min-height:44px; max-height:120px; line-height:1.4; }
    .ai-input:focus { outline:none; border-color:#1f6feb; box-shadow:0 0 0 3px rgba(31,111,235,0.1); }
    .ai-send-btn { background:#238636; border:1px solid #2ea043; color:white; padding:0.75rem; border-radius:8px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:all 0.2s; min-width:44px; height:44px; }
    .ai-send-btn:hover:not(:disabled) { background:#2ea043; }
    .ai-send-btn:disabled { opacity:0.5; cursor:not-allowed; }

    /* Misc */
    .hidden-input { display:none; }
    .rename-input { background:#0d1117; border:1px solid #30363d; color:#e6edf3; padding:0.25rem 0.5rem; border-radius:4px; font-size:0.8rem; width:100%; }
    @media (max-width:768px) {
      .editor-container { flex-direction:column; }
      .editor-panel { border-right:none; border-bottom:1px solid #30363d; }
      .editor-panel, .preview-panel { height:50vh; }
      .modal, .file-modal { min-width:90vw; margin:1rem; }
      .ai-chat { width: calc(100vw - 2rem); right:1rem; bottom:1rem; }
    }
  </style>
</head>

<body>
  <div class="editor-container">
    <div class="editor-panel">
      <div class="panel-header">
        <div class="panel-title">
          <span class="material-icons">edit</span>
          <div class="github-status">
            <div class="status-dot" id="githubStatusDot"></div>
            <span id="githubStatusText">Not connected</span>
          </div>
        </div>

        <div class="header-controls">
          <div class="status-indicator" id="saveStatus">Saved</div>

          <!-- File Management -->
          <div class="icon-btn" id="fileManagerBtn" title="File Manager">
            <span class="material-icons">folder</span>
          </div>

          <!-- AI Chat Toggle -->
          <div class="icon-btn" id="aiChatToggle" title="AI Assistant">
            <span class="material-icons">smart_toy</span>
          </div>

          <!-- Settings -->
          <div class="icon-btn" id="settingsBtn" title="GitHub Settings">
            <span class="material-icons">settings</span>
          </div>
        </div>
      </div>

      <!-- Filename bar: type filename, choose folder, save editor content as file -->
      <div class="filename-bar">
        <input id="filenameInput" class="filename-input" type="text" />
        <select id="filenameFolder" class="folder-select" title="Choose destination folder">
          <option value="_drafts">Drafts (_drafts)</option>
          <option value="_posts">Posts (_posts)</option>
        </select>
        <button id="saveEditorAsFile" class="save-editor-btn" title="Save current editor content to repository as a markdown file">
          <span class="material-icons">save</span>
          Save Editor
        </button>
      </div>

      <textarea class="editor-textarea" id="markdownEditor" placeholder="Write your post..."></textarea>

      <!-- AI Chat Interface -->
      <div class="ai-chat" id="aiChat">
        <div class="ai-chat-header">
          <div class="ai-chat-title">
            <span class="material-icons" style="font-size:18px;">smart_toy</span>
            AI Assistant
            <span class="ai-chat-model-name" id="aiChatModelName"></span>
          </div>
          <div class="icon-btn" id="aiChatClose" title="Close AI Chat">
            <span class="material-icons">close</span>
          </div>
        </div>
        <div class="ai-chat-body">
          <div class="ai-input-area">
            <textarea class="ai-input" id="aiInput" placeholder="Ask the assistant..."></textarea>
            <button class="ai-send-btn" id="aiSendBtn" title="Send">
              <span class="material-icons" style="font-size:20px;">send</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="preview-panel">
      <div class="panel-header">
        <div class="panel-title">
          <span class="material-icons">visibility</span>
          Live Preview
          <div class="preview-url" id="previewUrl">Loading...</div>
        </div>
        <div class="header-controls">
          <div class="auto-refresh-toggle">
            <span>Auto-refresh</span>
            <div class="toggle-switch active" id="autoRefreshToggle">
              <div class="toggle-slider"></div>
            </div>
          </div>
          <div class="icon-btn" id="refreshBtn" title="Refresh Preview">
            <span class="material-icons">refresh</span>
          </div>
        </div>
      </div>
      <div class="preview-content">
        <div class="preview-loading" id="previewLoading">
          <div class="loading-spinner"></div>
          <span>Loading preview...</span>
        </div>
        <iframe class="preview-iframe" id="previewFrame" style="display:none;"></iframe>
      </div>
    </div>
  </div>

  <!-- File Manager Modal -->
  <div class="modal-overlay" id="fileModal">
    <div class="modal file-modal">
      <div class="modal-header">
        <div class="modal-title">
          <span class="material-icons">folder</span>
          File Manager
        </div>
        <button class="modal-close" id="fileModalClose">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="modal-body">
        <div class="file-tabs">
          <button class="file-tab active" data-folder="_posts">
            <span class="material-icons" style="font-size:16px;">article</span>
            Posts
          </button>
          <button class="file-tab" data-folder="_drafts">
            <span class="material-icons" style="font-size:16px;">edit_note</span>
            Drafts
          </button>
          <button class="file-tab" data-folder="images">
            <span class="material-icons" style="font-size:16px;">image</span>
            Images
          </button>
        </div>

        <!-- Upload zone (still supports dragging files) -->
        <div class="upload-zone" id="uploadZone">
          <input type="file" id="fileUpload" multiple accept=".md,.markdown,image/*" />
          <div>
            <span class="material-icons" style="font-size:32px; margin-bottom:0.5rem;">cloud_upload</span>
            <div>Drag files here or click to upload</div>
            <div style="font-size:0.8rem; color:#7d8590; margin-top:0.5rem;">
              Supports .md, .markdown files and images
            </div>
          </div>
        </div>

        <!-- File list -->
        <div class="file-list" id="fileList">
          <div class="empty-state" id="emptyState">
            <span class="material-icons">folder_open</span>
            <div>No files found</div>
            <div style="font-size:0.8rem; margin-top:0.5rem;">Upload some files to get started</div>
          </div>
        </div>
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="fileModalCancel">Cancel</button>
        <button class="btn btn-primary" id="loadSelectedFile" disabled>
          <span class="material-icons" style="font-size:18px;">open_in_new</span>
          Load File
        </button>
      </div>
    </div>
  </div>

  <!-- GitHub Settings Modal -->
  <div class="modal-overlay" id="githubModal">
    <div class="modal">
      <div class="modal-header">
        <div class="modal-title">
          <span class="material-icons">settings</span>
          GitHub & AI Configuration
        </div>
        <button class="modal-close" id="modalClose">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="modal-body">
        <h3 style="color:#f0f6fc; margin-bottom:1rem;">GitHub Settings</h3>

        <div class="form-group">
          <label class="form-label" for="githubRepo">Repository (username/repo-name)</label>
          <input type="text" class="form-input" id="githubRepo" placeholder="your-username/your-blog-repo" autocomplete="url" />
          <div class="form-help">Enter your GitHub repository in the format: username/repository-name</div>
        </div>

        <div class="form-group">
          <label class="form-label" for="githubToken">Personal Access Token</label>
          <input type="password" class="form-input" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="current-password" />
          <div class="form-help">
            Create a token at <a href="https://github.com/settings/tokens" target="_blank" style="color:#58a6ff;">github.com/settings/tokens</a>
            with 'repo' and 'contents:write' permissions. Also works as GitHub Models token.
          </div>
        </div>

        <h3 style="color:#f0f6fc; margin:2rem 0 1rem 0;">AI Assistant Settings</h3>

        <div class="form-group">
          <label class="form-label" for="aiProvider">AI Provider</label>
          <select class="form-select" id="aiProvider">
            <option value="github">GitHub Models</option>
            <option value="gemini">Google Gemini</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label" for="geminiApiKey">Google Gemini API Key</label>
          <input type="password" class="form-input" id="geminiApiKey" placeholder="Enter your Gemini API Key" autocomplete="off" />
          <div class="form-help">Used when "Google Gemini" is selected as the provider.</div>
        </div>

        <div class="form-group">
          <label class="form-label" for="aiModelId">AI Model ID</label>
          <input type="text" class="form-input" id="aiModelId" placeholder="gpt-4o-mini" value="gpt-4o-mini" />
          <div class="form-help">Enter the model ID (e.g., gpt-4o-mini, gemini-1.5-flash-latest).</div>
        </div>

        <div class="form-group">
          <label class="form-label" for="aiSystemPrompt">System Instructions for AI</label>
          <textarea class="form-input" id="aiSystemPrompt" rows="6" placeholder="You are a helpful chess writing assistant..."></textarea>
          <div class="form-help">Customize how the AI assistant behaves and responds to your requests</div>
        </div>
      </div>

      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
        <button class="btn btn-primary" id="connectBtn">
          <span class="material-icons" style="font-size:18px;">save</span>
          Save Settings
        </button>
      </div>
    </div>
  </div>

  <script>
    class ChessEditorPreview {
      constructor() {
        this.editor = document.getElementById('markdownEditor');
        this.previewFrame = document.getElementById('previewFrame');
        this.previewLoading = document.getElementById('previewLoading');
        this.previewUrl = document.getElementById('previewUrl');
        this.saveStatus = document.getElementById('saveStatus');
        this.refreshBtn = document.getElementById('refreshBtn');
        this.autoRefreshToggle = document.getElementById('autoRefreshToggle');

        // GitHub elements
        this.githubModal = document.getElementById('githubModal');
        this.settingsBtn = document.getElementById('settingsBtn');
        this.githubStatusDot = document.getElementById('githubStatusDot');
        this.githubStatusText = document.getElementById('githubStatusText');
        this.modalClose = document.getElementById('modalClose');
        this.cancelBtn = document.getElementById('cancelBtn');
        this.connectBtn = document.getElementById('connectBtn');
        this.githubRepo = document.getElementById('githubRepo');
        this.githubToken = document.getElementById('githubToken');

        // File manager elements
        this.fileManagerBtn = document.getElementById('fileManagerBtn');
        this.fileModal = document.getElementById('fileModal');
        this.fileModalClose = document.getElementById('fileModalClose');
        this.fileModalCancel = document.getElementById('fileModalCancel');
        this.loadSelectedFileBtn = document.getElementById('loadSelectedFile');
        this.fileList = document.getElementById('fileList');
        this.emptyState = document.getElementById('emptyState');
        this.uploadZone = document.getElementById('uploadZone');
        this.fileUpload = document.getElementById('fileUpload');

        // Filename UI
        this.filenameInput = document.getElementById('filenameInput');
        this.filenameFolder = document.getElementById('filenameFolder');
        this.saveEditorAsFileBtn = document.getElementById('saveEditorAsFile');

        // AI Chat elements
        this.aiChatToggle = document.getElementById('aiChatToggle');
        this.aiChat = document.getElementById('aiChat');
        this.aiChatClose = document.getElementById('aiChatClose');
        this.aiInput = document.getElementById('aiInput');
        this.aiSendBtn = document.getElementById('aiSendBtn');
        this.aiSystemPrompt = document.getElementById('aiSystemPrompt');
        this.aiModelId = document.getElementById('aiModelId');
        this.aiProvider = document.getElementById('aiProvider');
        this.geminiApiKey = document.getElementById('geminiApiKey');
        this.aiChatModelName = document.getElementById('aiChatModelName');

        this.autoRefresh = true;
        this.updateTimeout = null;
        this.isFrameReady = false;
        this.aiChatOpen = false;
        this.currentFolder = '_posts';
        this.selectedFile = null;
        this.files = { '_posts': [], '_drafts': [], 'images': [] };

        // GitHub state
        this.github = { connected: false, repo: null, token: null, owner: null, repoName: null };

        this.init();
      }

      init() {
        // Default starter content if none saved
        const savedContent = localStorage.getItem('chessMarkdownEditor');
        if (savedContent) {
          this.editor.value = savedContent;
        } else {
          // User requested default frontmatter:
          this.editor.value = `---\ntitle: "Mastering Chess Openings"\ndate: 2025-08-08\nlayout: post\n---\n\nStart writing your chess post...`;
        }

        // Load saved filename value or compute
        this.filenameInput.value = this.computeAutoFilename();

        // Load saved GitHub credentials and AI settings
        this.loadSettings();

        // Setup event listeners
        this.editor.addEventListener('input', () => this.handleEditorInput());
        this.editor.addEventListener('keydown', (e) => this.handleTabKey(e));

        // Update filename suggestions on editor input
        this.editor.addEventListener('input', () => {
          const auto = this.computeAutoFilename();
          // only update filenameInput if user hasn't typed manually recently (simple heuristic)
          if (!this.filenameInput.dataset.manuallyEdited) {
            this.filenameInput.value = auto;
          }
        });

        this.filenameInput.addEventListener('input', () => {
          // mark as manually edited if user changes it
          this.filenameInput.dataset.manuallyEdited = '1';
        });

        this.refreshBtn.addEventListener('click', () => this.updatePreview(true));

        this.autoRefreshToggle.addEventListener('click', () => {
          this.autoRefresh = !this.autoRefresh;
          this.autoRefreshToggle.classList.toggle('active', this.autoRefresh);
          if (this.autoRefresh) {
            this.updatePreview();
          }
        });

        // GitHub event listeners
        this.settingsBtn.addEventListener('click', () => this.showGitHubModal());
        this.modalClose.addEventListener('click', () => this.hideGitHubModal());
        this.cancelBtn.addEventListener('click', () => this.hideGitHubModal());
        this.connectBtn.addEventListener('click', () => this.saveSettings());

        // File manager event listeners
        this.fileManagerBtn.addEventListener('click', () => this.showFileModal());
        this.fileModalClose.addEventListener('click', () => this.hideFileModal());
        this.fileModalCancel.addEventListener('click', () => this.hideFileModal());
        this.loadSelectedFileBtn.addEventListener('click', () => this.loadSelectedFile());

        // File tabs
        document.querySelectorAll('.file-tab').forEach(tab => {
          tab.addEventListener('click', () => this.switchFolder(tab.dataset.folder));
        });

        // Upload zone
        this.uploadZone.addEventListener('click', () => this.fileUpload.click());
        this.uploadZone.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.uploadZone.addEventListener('drop', (e) => this.handleDrop(e));
        this.fileUpload.addEventListener('change', () => this.handleFileUpload());

        // Save editor as file button
        this.saveEditorAsFileBtn.addEventListener('click', () => this.saveEditorAsFile());

        // AI Chat
        this.aiChatToggle.addEventListener('click', () => this.toggleAIChat());
        this.aiChatClose.addEventListener('click', () => this.toggleAIChat());
        this.aiSendBtn.addEventListener('click', () => this.sendAIMessage());
        this.aiInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.sendAIMessage();
          }
        });

        // Modal overlay clicks to close
        this.githubModal.addEventListener('click', (e) => {
          if (e.target === this.githubModal) {
            this.hideGitHubModal();
          }
        });

        this.fileModal.addEventListener('click', (e) => {
          if (e.target === this.fileModal) {
            this.hideFileModal();
          }
        });

        // Setup iframe message listener
        window.addEventListener('message', (event) => this.handleFrameMessage(event));

        // Initialize preview
        this.setupPreviewFrame();
      }

      loadSettings() {
        const savedRepo = localStorage.getItem('githubRepo');
        const savedToken = localStorage.getItem('githubToken');
        const savedProvider = localStorage.getItem('aiProvider');
        const savedGeminiKey = localStorage.getItem('geminiApiKey');
        const savedSystemPrompt = localStorage.getItem('aiSystemPrompt');
        const savedModelId = localStorage.getItem('aiModelId');

        if (savedRepo && savedToken) {
          this.githubRepo.value = savedRepo;
          this.githubToken.value = savedToken;
          this.connectToGitHub(false); // Connect silently
        }

        if (savedProvider) this.aiProvider.value = savedProvider;
        if (savedGeminiKey) this.geminiApiKey.value = savedGeminiKey;
        if (savedSystemPrompt) this.aiSystemPrompt.value = savedSystemPrompt;
        else {
          // default prompt
          this.aiSystemPrompt.value = `You are a helpful chess writing assistant. You specialize in creating engaging chess blog posts. When asked to generate or edit chess content, respond with JSON in this exact format: {"content":"<the full markdown document>", "message":"<brief description>"}.\nMake sure chess FENs and move notation are correct.`;
        }
        if (savedModelId) this.aiModelId.value = savedModelId;
        this.aiChatModelName.textContent = this.aiModelId.value;
      }

      showGitHubModal() { this.githubModal.classList.add('show'); this.githubRepo.focus(); }
      hideGitHubModal() { this.githubModal.classList.remove('show'); }

      showFileModal() {
        if (!this.github.connected) {
          this.showStatus('Please connect to GitHub first', 'error');
          return;
        }
        this.fileModal.classList.add('show');
        this.loadFileList();
      }
      hideFileModal() {
        this.fileModal.classList.remove('show');
        this.selectedFile = null;
        this.loadSelectedFileBtn.disabled = true;
      }

      switchFolder(folder) {
        this.currentFolder = folder;
        document.querySelectorAll('.file-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.folder === folder);
        });
        if (folder === 'images') {
          this.fileUpload.accept = 'image/*';
          this.uploadZone.querySelector('div > div:last-child').textContent = 'Supports images (jpg, png, gif, etc.)';
        } else {
          this.fileUpload.accept = '.md,.markdown';
          this.uploadZone.querySelector('div > div:last-child').textContent = 'Supports .md, .markdown files';
        }
        this.renderFileList();
      }

      async saveSettings() {
        const repo = this.githubRepo.value.trim();
        const token = this.githubToken.value.trim();
        const provider = this.aiProvider.value;
        const geminiKey = this.geminiApiKey.value.trim();
        const systemPrompt = this.aiSystemPrompt.value.trim();
        const modelId = this.aiModelId.value.trim();

        localStorage.setItem('aiProvider', provider);
        localStorage.setItem('geminiApiKey', geminiKey);
        localStorage.setItem('aiSystemPrompt', systemPrompt);
        localStorage.setItem('aiModelId', modelId);
        this.aiChatModelName.textContent = modelId;

        if (!repo || !token) {
          this.showStatus('Please fill in both repository and token', 'error');
          return;
        }

        if (!repo.includes('/')) {
          this.showStatus('Repository must be in format: username/repo-name', 'error');
          return;
        }

        this.connectBtn.disabled = true;
        this.connectBtn.innerHTML = '<div class="loading-spinner" style="width:16px;height:16px;"></div> Connecting...';

        try {
          const [owner, repoName] = repo.split('/');
          const response = await fetch(`https://api.github.com/repos/${repo}`, {
            headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/vnd.github.v3+json' }
          });

          if (!response.ok) throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
          const repoData = await response.json();

          localStorage.setItem('githubRepo', repo);
          localStorage.setItem('githubToken', token);

          this.github = { connected: true, repo: repo, token: token, owner: owner, repoName: repoName };
          this.updateGitHubStatus();

          this.hideGitHubModal();
          this.showStatus('Settings saved successfully!', 'success');

        } catch (error) {
          console.error('GitHub connection error:', error);
          this.showStatus(`Connection failed: ${error.message}`, 'error');
          this.github.connected = false;
          this.updateGitHubStatus();
        } finally {
          this.connectBtn.disabled = false;
          this.connectBtn.innerHTML = '<span class="material-icons" style="font-size:18px;">save</span> Save Settings';
        }
      }

      async connectToGitHub(showModal = true) {
        const repo = this.githubRepo.value.trim();
        const token = this.githubToken.value.trim();
        if (!repo || !token) return;
        try {
          const [owner, repoName] = repo.split('/');
          const response = await fetch(`https://api.github.com/repos/${repo}`, {
            headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/vnd.github.v3+json' }
          });
          if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
          this.github = { connected: true, repo: repo, token: token, owner: owner, repoName: repoName };
          this.updateGitHubStatus();
        } catch (error) {
          this.github.connected = false;
          this.updateGitHubStatus();
        }
      }

      updateGitHubStatus() {
        if (this.github.connected) {
          this.githubStatusDot.classList.add('connected'); this.githubStatusDot.classList.remove('error');
          this.githubStatusText.textContent = `Connected: ${this.github.repo}`;
        } else {
          this.githubStatusDot.classList.remove('connected'); this.githubStatusDot.classList.add('error');
          this.githubStatusText.textContent = 'Not connected';
        }
      }

      async loadFileList() {
        if (!this.github.connected) return;
        try {
          const folders = ['_posts', '_drafts', 'images'];
          const promises = folders.map(folder =>
            fetch(`https://api.github.com/repos/${this.github.repo}/contents/${folder}`, {
              headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json' }
            }).then(response => ({ folder, response })).catch(() => ({ folder, response: { ok: false, status: 404 } }))
          );
          const results = await Promise.all(promises);
          for (const { folder, response } of results) {
            if (response.ok) {
              const files = await response.json();
              this.files[folder] = files.filter(file => {
                if (folder === 'images') {
                  return file.type === 'file' && /\.(jpg|jpeg|png|gif|svg|webp)$/i.test(file.name);
                } else {
                  return file.type === 'file' && /\.(md|markdown)$/i.test(file.name);
                }
              });
            } else {
              this.files[folder] = [];
            }
          }
          this.renderFileList();
        } catch (error) {
          console.error('Error loading file list:', error);
          this.showStatus(`Failed to load files: ${error.message}`, 'error');
        }
      }

      renderFileList() {
        const files = this.files[this.currentFolder] || [];
        if (files.length === 0) {
          this.fileList.innerHTML = `
            <div class="empty-state">
              <span class="material-icons">folder_open</span>
              <div>No ${this.currentFolder === 'images' ? 'images' : 'files'} found</div>
              <div style="font-size:0.8rem; margin-top:0.5rem;">Upload some files to get started</div>
            </div>
          `;
          return;
        }
        this.fileList.innerHTML = files.map(file => `
          <div class="file-item" data-sha="${file.sha}" data-name="${file.name}" data-download-url="${file.download_url}">
            <div class="file-info">
              <div class="file-icon">
                <span class="material-icons">${this.getFileIcon(file.name)}</span>
              </div>
              <div class="file-details">
                <div class="file-name">${file.name}</div>
                <div class="file-meta">Size: ${this.formatFileSize(file.size)} â€¢ Modified: ${new Date(file.last_modified || Date.now()).toLocaleDateString()}</div>
              </div>
            </div>
            <div class="file-actions">
              ${this.currentFolder !== 'images' ? `<button class="file-action-btn" onclick="window.editor.renameFile('${file.sha}', '${file.name}')" title="Rename">
                <span class="material-icons" style="font-size:16px;">edit</span>
              </button>` : ''}
              <button class="file-action-btn danger" onclick="window.editor.deleteFile('${file.sha}', '${file.name}')" title="Delete">
                <span class="material-icons" style="font-size:16px;">delete</span>
              </button>
            </div>
          </div>
        `).join('');
        document.querySelectorAll('.file-item').forEach(item => {
          item.addEventListener('click', (e) => {
            if (e.target.closest('.file-actions')) return;
            document.querySelectorAll('.file-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');
            this.selectedFile = {
              sha: item.dataset.sha,
              name: item.dataset.name,
              downloadUrl: item.dataset.downloadUrl,
              folder: this.currentFolder
            };
            this.loadSelectedFileBtn.disabled = false;
          });
        });
      }

      getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        if (['jpg','jpeg','png','gif','svg','webp'].includes(ext)) return 'image';
        else if (['md','markdown'].includes(ext)) return 'article';
        return 'description';
      }

      formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024; const sizes = ['Bytes','KB','MB','GB']; const i = Math.floor(Math.log(bytes)/Math.log(k));
        return parseFloat((bytes/Math.pow(k,i)).toFixed(2)) + ' ' + sizes[i];
      }

      async loadSelectedFile() {
        if (!this.selectedFile) return;
        if (this.selectedFile.folder === 'images') {
          const imagePath = `./images/${this.selectedFile.name}`;
          const imageMarkdown = `![${this.selectedFile.name}](${imagePath})`;
          const cursorPos = this.editor.selectionStart;
          const before = this.editor.value.substring(0, cursorPos);
          const after = this.editor.value.substring(cursorPos);
          this.editor.value = before + '\n\n' + imageMarkdown + '\n\n' + after;
          localStorage.setItem('chessMarkdownEditor', this.editor.value);
          if (this.autoRefresh) this.updatePreview();
          this.hideFileModal();
          this.showStatus(`Inserted ${this.selectedFile.name} into editor`, 'success');
          return;
        }

        try {
          this.showStatus('Loading file...', 'loading');
          const response = await fetch(this.selectedFile.downloadUrl);
          if (!response.ok) throw new Error(`Failed to load file: ${response.statusText}`);
          const content = await response.text();
          this.editor.value = content;
          localStorage.setItem('chessMarkdownEditor', content);
          this.filenameInput.value = this.computeAutoFilename(); // update autofill
          this.showStatus(`Loaded ${this.selectedFile.name}`, 'success');
          if (this.autoRefresh) this.updatePreview();
          this.hideFileModal();
        } catch (error) {
          console.error('Error loading file:', error);
          this.showStatus(`Failed to load file: ${error.message}`, 'error');
        }
      }

      async renameFile(sha, currentName) {
        const newName = prompt('Enter new filename:', currentName);
        if (!newName || newName === currentName) return;
        try {
          this.showStatus('Renaming file...', 'loading');
          const file = this.files[this.currentFolder].find(f => f.sha === sha);
          if (!file) throw new Error('File not found');
          const contentResponse = await fetch(file.download_url);
          if (!contentResponse.ok) throw new Error('Failed to fetch file content');
          const content = await contentResponse.text();
          const createResponse = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${this.currentFolder}/${newName}`, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Rename ${currentName} to ${newName}`, content: btoa(unescape(encodeURIComponent(content))), branch: 'main' })
          });
          if (!createResponse.ok) throw new Error(`Failed to create new file: ${createResponse.statusText}`);
          const deleteResponse = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${this.currentFolder}/${currentName}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Delete old file ${currentName}`, sha: sha, branch: 'main' })
          });
          if (!deleteResponse.ok) console.warn('Failed to delete old file, but rename succeeded');
          this.showStatus(`Renamed ${currentName} to ${newName}`, 'success');
          this.loadFileList();
        } catch (error) {
          console.error('Error renaming file:', error);
          this.showStatus(`Failed to rename file: ${error.message}`, 'error');
        }
      }

      async deleteFile(sha, filename) {
        if (!confirm(`Are you sure you want to delete "${filename}"?`)) return;
        try {
          this.showStatus('Deleting file...', 'loading');
          const response = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${this.currentFolder}/${filename}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Delete ${filename}`, sha: sha, branch: 'main' })
          });
          if (!response.ok) throw new Error(`Failed to delete file: ${response.statusText}`);
          this.showStatus(`Deleted ${filename}`, 'success');
          this.loadFileList();
        } catch (error) {
          console.error('Error deleting file:', error);
          this.showStatus(`Failed to delete file: ${error.message}`, 'error');
        }
      }

      handleDragOver(e) { e.preventDefault(); this.uploadZone.classList.add('drag-over'); }
      handleDrop(e) { e.preventDefault(); this.uploadZone.classList.remove('drag-over'); this.fileUpload.files = e.dataTransfer.files; this.handleFileUpload(); }
      async handleFileUpload() {
        const files = Array.from(this.fileUpload.files);
        if (files.length === 0) return;
        this.showStatus('Uploading files...', 'loading');
        try {
          for (const file of files) await this.uploadSingleFile(file);
          this.showStatus(`Successfully uploaded ${files.length} file(s)!`, 'success');
          this.loadFileList();
        } catch (error) {
          console.error('Upload error:', error);
          this.showStatus(`Upload failed: ${error.message}`, 'error');
        }
        this.fileUpload.value = '';
      }

      async uploadSingleFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = async () => {
            try {
              const base64Content = reader.result.split(',')[1];
              const filename = file.name;
              let sha = null;
              try {
                const existingFileResponse = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${this.currentFolder}/${filename}`, {
                  headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (existingFileResponse.ok) {
                  const existingFile = await existingFileResponse.json();
                  sha = existingFile.sha;
                }
              } catch (error) { /* file may not exist */ }
              const uploadData = { message: sha ? `Update ${filename}` : `Add ${filename}`, content: base64Content, branch: 'main' };
              if (sha) uploadData.sha = sha;
              const uploadResponse = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${this.currentFolder}/${filename}`, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                body: JSON.stringify(uploadData)
              });
              if (!uploadResponse.ok) {
                const errorData = await uploadResponse.json();
                throw new Error(errorData.message || `Failed to upload ${filename}`);
              }
              resolve(filename);
            } catch (error) { reject(error); }
          };
          reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
          reader.readAsDataURL(file);
        });
      }

      // Save current editor content as a markdown file to the selected folder (without selecting an external file)
      async saveEditorAsFile() {
        if (!this.github.connected) {
          this.showStatus('Please connect to GitHub first', 'error');
          return;
        }
        let folder = this.filenameFolder.value || '_drafts';
        let filename = (this.filenameInput.value || '').trim();
        if (!filename) {
          filename = this.computeAutoFilename();
          this.filenameInput.value = filename;
        }
        // Ensure .md extension
        if (!/\.md$/i.test(filename)) filename = filename.replace(/\.+$/, '') + '.md';

        const content = this.editor.value;
        const b64 = btoa(unescape(encodeURIComponent(content)));
        this.showStatus(`Saving ${filename} to ${folder}...`, 'loading');

        try {
          // check existing file to get sha
          let sha = null;
          try {
            const existsResp = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${folder}/${filename}`, {
              headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json' }
            });
            if (existsResp.ok) {
              const existingFile = await existsResp.json();
              sha = existingFile.sha;
            }
          } catch (err) { /* ignore not found */ }

          const body = { message: sha ? `Update ${filename}` : `Add ${filename}`, content: b64, branch: 'main' };
          if (sha) body.sha = sha;

          const uploadResp = await fetch(`https://api.github.com/repos/${this.github.repo}/contents/${folder}/${filename}`, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${this.github.token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          if (!uploadResp.ok) {
            const errData = await uploadResp.json();
            throw new Error(errData.message || `Failed to save ${filename}`);
          }

          this.showStatus(`Saved ${filename} to ${folder}`, 'success');
          this.loadFileList();
        } catch (error) {
          console.error('Save editor file error:', error);
          this.showStatus(`Save failed: ${error.message}`, 'error');
        }
      }

      // Compute auto filename from frontmatter title+date, or fallback to draft{timestamp}.md
      computeAutoFilename() {
        const markdown = this.editor.value || '';
        const yamlMatch = markdown.match(/^---\n([\s\S]*?)\n---\n?/);
        if (yamlMatch) {
          const front = this.parseYAML(yamlMatch[1]);
          const title = (front.title || '').toString().trim();
          const date = (front.date || '').toString().trim();
          if (title) {
            // sanitize title
            const slug = title.toLowerCase().replace(/["']/g, '').replace(/[^a-z0-9\s-]/g, '').trim().replace(/\s+/g, '-');
            const d = date || new Date().toISOString().split('T')[0];
            const safeDate = d.replace(/[: ]/g, '-');
            return `${safeDate}-${slug}.md`;
          }
        }
        // fallback
        const now = new Date();
        const pad = (n) => (n < 10 ? '0' + n : n);
        const stamp = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
        return `draft${stamp}.md`;
      }

      // AI helpers
      toggleAIChat() {
        this.aiChatOpen = !this.aiChatOpen;
        this.aiChat.classList.toggle('open', this.aiChatOpen);
        this.aiChatToggle.classList.toggle('active', this.aiChatOpen);
        if (this.aiChatOpen) this.aiInput.focus();
      }

      async sendAIMessage() {
        const message = this.aiInput.value.trim();
        if (!message) return;
        const provider = this.aiProvider.value;
        this.aiInput.value = '';
        this.aiSendBtn.disabled = true;
        this.aiSendBtn.innerHTML = '<div class="loading-spinner" style="width:16px;height:16px;"></div>';
        try {
          if (provider === 'github') await this.sendGitHubAIMessage(message);
          else if (provider === 'gemini') await this.sendGeminiAIMessage(message);
        } catch (error) {
          console.error('AI error:', error);
          this.showStatus(`AI error: ${error.message}`, 'error');
        } finally {
          this.aiSendBtn.disabled = false;
          this.aiSendBtn.innerHTML = '<span class="material-icons" style="font-size:18px;">send</span>';
          this.aiInput.focus();
        }
      }

      async sendGitHubAIMessage(message) {
        if (!this.github.token) throw new Error('Please set up GitHub token for AI features');
        const systemPrompt = this.aiSystemPrompt.value;
        const modelId = this.aiModelId.value || 'gpt-4o-mini';

        const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${this.github.token}` },
          body: JSON.stringify({
            model: modelId,
            messages: [
              { role: 'system', content: `${systemPrompt}\n\nIMPORTANT: Respond with valid JSON exactly like: {"content":"<full markdown>","message":"<short note>"}` },
              { role: 'user', content: message }
            ],
            temperature: 0.7,
            max_tokens: 4000
          })
        });

        if (!response.ok) throw new Error(`GitHub AI API error: ${response.status} ${response.statusText}`);

        const data = await response.json();
        const aiResponse = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
          ? data.choices[0].message.content : JSON.stringify(data);
        this.processAIResponse(aiResponse);
      }

      // Use Gemini generateContent with responseSchema so we receive structured JSON (content + message)
      async sendGeminiAIMessage(message) {
        const apiKey = this.geminiApiKey.value.trim();
        if (!apiKey) throw new Error('Please provide your Google Gemini API Key');

        const systemPrompt = this.aiSystemPrompt.value;
        const modelId = this.aiModelId.value || 'gemini-1.5-flash-latest';

        // Build generationConfig similar to the example provided by user
        const requestBody = {
          contents: [{
            parts: [{ text: `${systemPrompt}\n\nIMPORTANT: You MUST return valid JSON exactly in the shape: { "content": "<the full markdown content>", "message": "<brief note>" }.\nCurrent document content:\n${this.editor.value}\n\nUser request: ${message}` }]
          }],
          generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
              type: "OBJECT",
              properties: {
                content: { type: "STRING" },
                message: { type: "STRING" }
              },
              propertyOrdering: ["content", "message"]
            },
            temperature: 0.7,
            maxOutputTokens: 4000
          }
        };

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Gemini API error: ${response.status} ${response.statusText} â€” ${text}`);
        }

        const data = await response.json();

        // Gemini response structure: inspect candidates -> content -> parts[].text
        let fullText = '';
        try {
          if (data && data.candidates && data.candidates.length) {
            const c = data.candidates[0];
            if (c && c.content && c.content.parts) {
              for (const p of c.content.parts) {
                if (p.text) fullText += p.text;
              }
            }
          } else if (data.output && Array.isArray(data.output)) {
            // fallback in case of different shape
            for (const out of data.output) {
              if (out.content && out.content[0] && out.content[0].text) fullText += out.content[0].text;
            }
          } else {
            fullText = JSON.stringify(data);
          }

          // sanitize code fences if present
          if (fullText.startsWith('```json')) {
            fullText = fullText.replace(/^```json\s*/, '').replace(/\s*```$/, '');
          } else if (fullText.startsWith('```')) {
            fullText = fullText.replace(/^```\s*/, '').replace(/\s*```$/, '');
          }

          this.processAIResponse(fullText);
        } catch (err) {
          console.error('Error parsing Gemini response:', err);
          this.processAIResponse(fullText || JSON.stringify(data));
        }
      }

      processAIResponse(aiResponse) {
        try {
          const jsonResponse = typeof aiResponse === 'string' ? JSON.parse(aiResponse) : aiResponse;
          if (jsonResponse && jsonResponse.content) {
            this.editor.value = jsonResponse.content;
            localStorage.setItem('chessMarkdownEditor', this.editor.value);
            if (this.autoRefresh) this.updatePreview();
            this.showStatus(jsonResponse.message || 'Content updated by AI', 'success');
            this.toggleAIChat();
            // update filename suggestion from new frontmatter
            this.filenameInput.value = this.computeAutoFilename();
            return;
          }
        } catch (parseError) {
          // try to extract JSON embedded in text
          const jsonMatch = (aiResponse || '').toString().match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            try {
              const extracted = JSON.parse(jsonMatch[0]);
              if (extracted.content) {
                this.editor.value = extracted.content;
                localStorage.setItem('chessMarkdownEditor', this.editor.value);
                if (this.autoRefresh) this.updatePreview();
                this.showStatus(extracted.message || 'Content updated by AI', 'success');
                this.toggleAIChat();
                this.filenameInput.value = this.computeAutoFilename();
                return;
              }
            } catch (innerErr) {
              // fall through
            }
          }
        }

        // final fallback: treat response as direct markdown content
        this.editor.value = aiResponse;
        localStorage.setItem('chessMarkdownEditor', this.editor.value);
        if (this.autoRefresh) this.updatePreview();
        this.showStatus('Content updated by AI', 'success');
        this.toggleAIChat();
        this.filenameInput.value = this.computeAutoFilename();
      }

      setupPreviewFrame() {
        const postHtmlUrl = '_layouts/post.html';
        this.previewUrl.textContent = postHtmlUrl;
        this.previewFrame.src = postHtmlUrl;
        this.previewFrame.onload = () => {
          this.previewLoading.style.display = 'none'; this.previewFrame.style.display = 'block';
          setTimeout(() => { this.isFrameReady = true; this.updatePreview(); }, 500);
        };
        this.previewFrame.onerror = () => {
          this.previewLoading.innerHTML = `
            <span style="color:#f85149;">
              âš ï¸ Failed to load post.html<br>
              <small>Make sure post.html is accessible at: ${postHtmlUrl}</small>
            </span>
          `;
        };
      }

      handleFrameMessage(event) {
        if (event.data.type === 'preview-ready') { this.isFrameReady = true; this.updatePreview(); }
        else if (event.data.type === 'preview-updated') { console.log('Preview updated successfully'); }
        else if (event.data.type === 'preview-error') { console.error('Preview error:', event.data.error); }
      }

      handleEditorInput() {
        localStorage.setItem('chessMarkdownEditor', this.editor.value);
        this.showSaveStatus();
        if (this.autoRefresh) this.scheduleUpdate();
      }

      handleTabKey(e) {
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = this.editor.selectionStart;
          const end = this.editor.selectionEnd;
          this.editor.value = this.editor.value.substring(0, start) + '  ' + this.editor.value.substring(end);
          this.editor.selectionStart = this.editor.selectionEnd = start + 2;
        }
      }

      scheduleUpdate() {
        clearTimeout(this.updateTimeout);
        this.updateTimeout = setTimeout(() => this.updatePreview(), 800);
      }

      updatePreview(force = false) {
        if (!this.isFrameReady && !force) return;
        const markdown = this.editor.value;
        const processed = this.processMarkdown(markdown);
        this.previewFrame.contentWindow.postMessage({
          type: 'update-content',
          frontMatter: processed.frontMatter,
          content: processed.content,
          rawMarkdown: markdown
        }, '*');
        this.refreshBtn.disabled = true;
        setTimeout(() => this.refreshBtn.disabled = false, 1000);
      }

      processMarkdown(markdown) {
        const result = { frontMatter: {}, content: '' };
        const yamlMatch = markdown.match(/^---\n([\s\S]*?)\n---\n?([\s\S]*)$/);
        if (yamlMatch) {
          result.frontMatter = this.parseYAML(yamlMatch[1]);
          result.content = yamlMatch[2];
        } else {
          result.frontMatter = { title: "Preview Post", date: new Date().toISOString().split('T')[0], layout: "post" };
          result.content = markdown.replace(/^---[\s\S]*?---\n?/, '');
        }
        return result;
      }

      parseYAML(yamlStr) {
        const lines = yamlStr.split('\n').filter(line => line.trim());
        const data = {};
        lines.forEach(line => {
          const colonIndex = line.indexOf(':');
          if (colonIndex > 0) {
            const key = line.substring(0, colonIndex).trim();
            let value = line.substring(colonIndex + 1).trim();
            if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
              value = value.slice(1, -1);
            }
            data[key] = value;
          }
        });
        return data;
      }

      showSaveStatus() {
        this.saveStatus.textContent = 'Saving...';
        this.saveStatus.classList.add('show');
        this.saveStatus.classList.remove('error', 'warning');
        setTimeout(() => {
          this.saveStatus.textContent = 'Saved';
          setTimeout(() => this.saveStatus.classList.remove('show'), 1000);
        }, 500);
      }

      showStatus(message, type = 'info') {
        this.saveStatus.classList.remove('error', 'warning');
        if (type === 'error') { this.saveStatus.classList.add('error'); }
        else if (type === 'warning') { this.saveStatus.classList.add('warning'); }
        this.saveStatus.textContent = message;
        this.saveStatus.classList.add('show');
        if (type !== 'loading') {
          setTimeout(() => this.saveStatus.classList.remove('show'), type === 'error' ? 4000 : 2000);
        }
      }
    }

    // Initialize the editor and expose it globally for file operations
    document.addEventListener('DOMContentLoaded', () => {
      window.editor = new ChessEditorPreview();
    });
  </script>
</body>

</html>
