---
layout: default
---
<article class="markdown-body glass-panel" style="padding: 2rem;">
  <h1>{{ page.title }}</h1>

  <div class="post-meta" style="color: var(--text-muted); font-size: 0.95em; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
    <div>
      <time datetime="{{ page.date | date_to_xmlschema }}">{{ page.date | date: "%B %d, %Y" }}</time>
      {% if page.last_modified_at %}
      • Updated: <time datetime="{{ page.last_modified_at | date_to_xmlschema }}">{{ page.last_modified_at | date: "%B %d, %Y" }}</time>
      {% endif %}
    </div>

    {% if page.tags %}
    <div class="tags-container">
      {% for tag in page.tags %}
        <a href="{{ '/tags/' | append: tag | slugify | append: '/' | relative_url }}" class="tag-chip">{{ tag }}</a>
      {% endfor %}
    </div>
    {% endif %}
  </div>

  {% if page.image %}
  <div class="article-image-wrapper">
    <img src="{{ page.image }}" alt="{{ page.title }}" style="width: 100%; border-radius: 8px; margin-bottom: 1.5rem;" />
  </div>
  {% endif %}

  {{ content }}
</article>

{% include related-posts.html %}

<style>
  /* Inline overrides for specific post layout needs if any */
  .inline-chess-board-container { display: flex; justify-content: center; margin: 2em 0; }
  /* Styles for the chess board renderer are now expected to be either in learn.css or inline here.
     Since the previous post.html had a large script for rendering chess boards, we need to preserve that functionality.
     I will re-add the chess board script below.
  */
  .inline-chess-board { position: relative; border: 3px solid #2d3748; border-radius: 8px; background: #2d3748; display: inline-block; box-shadow: 0 8px 24px rgba(0,0,0,0.25); }
  .inline-chess-board-grid { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); }
  .inline-chess-square { width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; font-size: 22px; position: relative; transition: all 0.2s; z-index: 1; }
  .inline-chess-square.light { background: #f0d9b5; }
  .inline-chess-square.dark { background: #b58863; }
  .inline-chess-square.highlighted { background: #ffff00cc !important; outline: 0.1px solid #0000001a; }
  .inline-chess-square.from-square { background: #ff6b6bcc !important; }
  .inline-chess-square.to-square { background: #4ecdc4cc !important; outline: 0.1px solid #0000001a; }
  .inline-chess-board .inline-chess-piece { width: 90%; height: 90%; object-fit: contain; user-select: none; display: block; margin: 0; box-shadow: none; border-radius: 0; max-width: unset; max-height: unset; z-index: 20; }
  .inline-chess-arrows { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
  .inline-chess-coord { position: absolute; font-size: 12px; font-weight: bold; color: #a0a0a0; pointer-events: none; user-select: none; z-index: 20; }
  .inline-chess-file-coord { bottom: -20px; left: 50%; transform: translateX(-50%); }
  .inline-chess-rank-coord { left: -20px; top: 50%; transform: translateY(-50%); }
</style>

<script>
    // Inline Chess Board Renderer for blog posts (Preserved from original)
    const pieceImages = { 'K':'wK','Q':'wQ','R':'wR','B':'wB','N':'wN','P':'wP','k':'bK','q':'bQ','r':'bR','b':'bB','n':'bN','p':'bP' };
    const baseImageUrl = '/assests/'; // Note: Typo in original code 'assests' preserved, check if it should be 'assets'

    function renderChessBoard(el, fen, highlights, arrows) {
      const container = document.createElement('div');
      container.className = 'inline-chess-board-container';
      const board = document.createElement('div');
      board.className = 'inline-chess-board';
      board.style.position = 'relative';

      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.classList.add('inline-chess-arrows');
      svg.setAttribute('width','304');
      svg.setAttribute('height','304');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      board.appendChild(svg);

      const grid = document.createElement('div');
      grid.className = 'inline-chess-board-grid';

      const fenParts = fen.split(' ');
      const position = fenParts[0];
      const ranks = position.split('/');
      for (let rank = 0; rank < 8; rank++) {
        let file = 0;
        for (let i = 0; i < ranks[rank].length; i++) {
          const char = ranks[rank][i];
          if (isNaN(char)) {
            const sq = createSquare(rank, file, char);
            grid.appendChild(sq);
            file++;
          } else {
            const emptyCount = parseInt(char);
            for (let k = 0; k < emptyCount; k++) {
              const sq = createSquare(rank, file, null);
              grid.appendChild(sq);
              file++;
            }
          }
        }
      }

      board.appendChild(grid);

      for (let i = 0; i < 8; i++) {
        const coord = document.createElement('div');
        coord.className = 'inline-chess-coord inline-chess-file-coord';
        coord.textContent = String.fromCharCode(97 + i);
        coord.style.left = (i * 38 + 19) + 'px';
        coord.style.bottom = '-20px';
        board.appendChild(coord);
      }

      for (let i = 0; i < 8; i++) {
        const coord = document.createElement('div');
        coord.className = 'inline-chess-coord inline-chess-rank-coord';
        coord.textContent = 8 - i;
        coord.style.top = (i * 38 + 19) + 'px';
        coord.style.left = '-20px';
        board.appendChild(coord);
      }

      container.appendChild(board);
      el.parentNode.replaceChild(container, el);

      if (highlights && highlights.length) {
        highlights.forEach(sq => {
          const s = grid.querySelector(`[data-square="${sq}"]`);
          if (s) s.classList.add('highlighted');
        });
      }

      if (arrows && arrows.length) {
        arrows.forEach(arr => {
          const parts = arr.split('-');
          if (parts.length === 2) drawArrow(grid, svg, parts[0], parts[1]);
        });
      }
    }

    function createSquare(rank, file, piece) {
      const sq = document.createElement('div');
      sq.className = 'inline-chess-square ' + ((rank + file) % 2 === 0 ? 'light' : 'dark');
      sq.dataset.square = String.fromCharCode(97 + file) + (8 - rank);
      if (piece) {
        const img = document.createElement('img');
        img.className = 'inline-chess-piece';
        img.src = baseImageUrl + (pieceImages[piece] || piece) + '.svg';
        img.alt = piece;
        img.onerror = function () {
          const fallback = { 'K':'♔','Q':'♕','R':'♖','B':'♗','N':'♘','P':'♙','k':'♚','q':'♛','r':'♜','b':'♝','n':'♞','p':'♟' };
          const span = document.createElement('span');
          span.className = 'inline-chess-piece';
          span.textContent = fallback[piece] || piece;
          span.style.fontSize = '22px';
          this.parentNode.replaceChild(span, this);
        };
        sq.appendChild(img);
      }
      return sq;
    }

    function drawArrow(grid, svg, from, to, color = '#ff6b6b') {
      const fromSq = grid.querySelector(`[data-square="${from}"]`);
      const toSq = grid.querySelector(`[data-square="${to}"]`);
      if (!fromSq || !toSq) return;

      const getPos = sq => {
        const idx = Array.prototype.indexOf.call(grid.children, sq);
        const x = idx % 8;
        const y = Math.floor(idx / 8);
        return [x * 38 + 19, y * 38 + 19];
      };
      const [x1, y1] = getPos(fromSq);
      const [x2, y2] = getPos(toSq);

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '2.2');
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('marker-end', 'url(#inline-arrowhead)');

      let defs = svg.querySelector('defs');
      if (!defs) {
        defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
        svg.appendChild(defs);
      }

      // recreate marker so color can change
      const oldMarker = defs.querySelector('#inline-arrowhead');
      if (oldMarker) oldMarker.remove();

      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id', 'inline-arrowhead');
      marker.setAttribute('markerWidth', '6');
      marker.setAttribute('markerHeight', '4');
      marker.setAttribute('refX', '5.5');
      marker.setAttribute('refY', '2');
      marker.setAttribute('orient', 'auto');

      const polygon = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      polygon.setAttribute('points', '0 0, 6 2, 0 4');
      polygon.setAttribute('fill', color);
      polygon.setAttribute('stroke', '#fff');
      polygon.setAttribute('stroke-width', '0.8');

      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(line);

      fromSq.classList.add('from-square');
      toSq.classList.add('to-square');
    }

    document.addEventListener('DOMContentLoaded', function () {
      document.querySelectorAll('chess-board').forEach(el => {
        const fen = el.getAttribute('fen') || '8/8/8/8/8/8/8/8 w - - 0 1';
        const highlights = (el.getAttribute('highlight') || '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
        const arrows = (el.getAttribute('arrows') || '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
        renderChessBoard(el, fen, highlights, arrows);
      });
    });
</script>
